5210: 最大连通子块和 动态DP 树链剖分

国际惯例的题面:

这题......最大连通子块和显然可以DP，加上修改显然就是动态DP了......
考虑正常情况下怎么DP:
我们令a[i]表示选择i及i的子树中的一些点，最大连通子块和;
b[i]表示在i的子树中选择一些点(不一定包含i)，最大连通子块和。
那么我们要询问i的子树的话，答案就是b[i]了。
考虑这个DP怎么转移，a[i]=max(sigma(j:SON_i)a[j]+v[i],0),b[i]=max((j:SON_i)b[j],a[i])。
陈俊锟说过，树上动态DP，就是把树拆成链，分离轻重儿子的转移。
于是我们重新定义DP:
f[i]表示从i所在的重链到i，选择连续一段和连续一段的子树，最大连通子块和(可以不包含i选择空段，类似a[i]);
g[i]表示计算i这个点本身和i的虚孩子们，形成的最大连续子块和。
dp[i]表示从i所在的重链到i，选择连续一段和连续一段的子树，或者从某个点的虚孩子中选择一个连通块，最大连通子块和(显然这个不一定包含i)。
这样的话，我们的转移就有:
g[i]=v[i]+sigma(j:LIGHTSON_i)f[j],f[i]=max(g[i]+f[HEAVYSON_i],0),dp[pos]=max(f[i],dp[HEAVYSON_i],max((j:LIGHTSON_i)dp[j]))。
这个转移初始化的话直接线性DP一遍就好了。
考虑怎么动态，这里的轻重孩子的转移都定义好了，我们只需要修改一些点的g和dp值，给他的父亲所在的重链当做输入值就好。
考虑怎么查询，如果是一条链的话，我们查询的就是最大子段和。树上的话，我们对于重链，也能查询g的最大子段和。
对于最优解不在这条链上的情况，我们用这个点的所有轻儿子的dp值去更新它单点的最大连续子段和就好，显然这是正确的。
也就是说，我们还需要维护一下DP值。考虑DP值是取max，所以用multiset去维护一下就好。
(其实这题我本来想写类似矩阵乘法的DP转移的，然后发现不会查询，于是只好分析题目性质列DP了)

代码:

いろ褪せたペ`ジの记忆
封存在褪色书页里的记忆
瞳闭じれば苏る
倘若闭上眼睛的话便会再度浮现
あどけない少女の祈り
少女那天真纯洁的祈望
羽ばたけよ 希望の空へ
振翅飞翔吧，向着希望的天空

叹く间もなく 时は流れる
时间在静静流逝，连叹息的时间也没有了
ひとり立ち止まるけど
但是却独身一人停下了脚步

树链剖分维护动态DP