20180516小测

我也没什么可以说的了。

T1:

我们能够证明(显然)这样的一个网络能输出任何[0,2^n-1]的排列(可以用归纳法证明)，于是-1是不存在的了。
考虑每个节点只有两种状态，能否2-sat做呢？似乎有一些节点的状态是存在依赖关系的，然而并不会建图。
(于是我就写了20分暴力，先枚举那些节点激活然后进行大模拟)
正解是考虑这个网络的形态，观察可得一个节点输出的两个信号会被分配到左右的两个子网络中。
如果我们想构造出解的话，需要让第一次每个节点的两个信号进入两个不同的子网络，最后一层每个节点的两个信号从两个不同的子网络中得来。这个就是依赖关系了。
等等，这个似乎不需要2-sat，因为要字典序最小，我们能钦定第一行第一个节点状态为0，然后通过数值关系推出每个数字必须在哪个子网络中，这样与1号节点存在依赖关系的节点的状态也就都确定了。
然后继续扫描第一行，如果存在某个节点的状态没有被确定，那么让他为0与前面最优化的答案一定不冲突，我们就让他为0，然后继续递推就好了。
然后完成某一级的答案求解后，递归求出两个子网络的状态即可。
复杂度O(n*2^n)。

20分暴力代码:

正解代码:
(原谅我代码写得像天书一样)

T2:

观察这个生成的序列，发现没什么性质(没错，它最大的性质就是随机！)。
于是没什么好办法，只好用数据结构做了。
平衡树和线段树是不用想了，铁定TLE(线段树还会MLE)，我们需要一个更优美的做法。
用堆！一个大根堆维护序列的前半部分，一个小根堆维护序列的后半部分。
每次把新生成的数插入前半部分的大根堆，当这个堆的大小比(i+1)/2大时，弹出堆顶并把堆顶放进后半部分的小根堆。
如果当前大根堆堆顶比小根堆堆顶大的话，我们就交换这两个堆顶的元素(两个push两个pop)。
显然对于插入的每个数字，第一种操作只会进行1次，对于每一个i，第二种操作只会进行O(1)次，总复杂度O(nlogn)。
很不幸的是，这样做也只有50分，即使你用pb_ds的配对堆或斐波那契堆。
考虑复杂度瓶颈在哪里，我们每次对堆进行操作的时候，都要承受一个巨大的log。
好的，我们还是维护两个堆，在中间维护一棵平衡树作为缓存，保证当前查询的那个数值永远在平衡树里。用这棵平衡树减少堆的操作并限制它的大小来减小log，是不是就能卡过去了呢？
具体操作就是，插入的时候判断新加的值在那一段，加入正确的位置；
当平衡树的大小和第一个堆大小的和比当前要查询的数值小时，从第二个堆中取出数字放进平衡树中；
当平衡树的大小比阈值大时，把平衡树开始或结尾的元素移动到大小较小的那个堆中。
因为数据随机，所以如果平衡树缓存大小合适，我们对两边的堆的操作会大幅度减少，于是就可以AC了。

50分暴力代码:

正解代码:

T3:

博弈论+数据结构？
SG函数怎么推啊......只知道P为奇数时，SG值为当前元素的奇偶性。数据不保证P的奇偶，写了也不一定有分，弃疗了。
假设我们打表观察(出题人写的)这个题的SG函数是这样的:
当P为奇数时，大小为n的堆的SG值为 n mod 2。
当P为偶数时，大小为n的堆的SG值为:
如果 n mod P + 1 = P , 则为2；
否则为 n mod P + 1 mod 2。
考虑怎么证明。
P为奇数时的SG值显然，因为每次操作一定改变堆大小的奇偶性。
P为偶数时的证明就比较麻烦了......
因为a^2-1=(a+1)*(a-1)，故 a^2-1+1=(a+1)*(a-1)+1 = 1 mod a+1 ， 所以 a^3 = a * a^2 = a mod a+1。
所以，取p^k的情况，在mod p+1下都能划归为取1或者取p的情况。
所以我们可以在P+1的同余系下做。如果 mod P+1 < P 的话，只能取1，所以SG值为 n mod P + 1 mod 2 。
而mod P+1 = P的情况，我们可以取p，到SG值为0的状态0和SG值为1的状态P-1，故这个状态的SG值为mex(1,2)=2。

于是我们对于P为奇数和偶数的情况分别计算。
P为奇数的话，相当于区间 xor 1，求区间 xor 和，线段树轻松搞定。
P为偶数的情况，我们需要分块。
考虑我们先让所有数值mod P+1再按照mod 2将这些数值放入两个有序数组里。
那么，如果区间同时加上add，所有>=P+1-add的数会溢出一轮。
如果add为偶数的话，溢出的数的奇偶性改变，没溢出的数的奇偶性不变；
如果add为奇数的话，溢出的数的奇偶性不变，没溢出的数的奇偶性改变。
这样我们维护两个有序数组每次lower_bound一下就好了，当然如果你非得写平衡树也没人拦你。
(什么？mod P+1 = P的？满足这种情况的只有一个数就是P+1-add，我们用一个map存mod P+1为某个数的值有多少个，再手动从奇偶两种减去这个值的贡献就好了)

代码:


流れるgに指先重ねて
流云间十指相扣
Lした何rかと 同じ色のを
埋藏着与那个时候同色的阳光
光を追いかけ 知らない街を
我于不曾知晓的街道上追逐着那束光芒
独りでiいた 又逢う日粢て
独自一人行走 而又回想起相遇的那天
护à郡い 忘れられないあの景色も
想要告诉你 那道难以忘怀的风景
今は瞳の奥に色褪せないように
如今也仍在眼眸深处不曾褪色
空を{る路 足E一つでも
追寻着天空的路上 只存留着我的足迹
このrのはてにF方が若し居るなら
如果这个时候有你在我身旁的话
少しだけで好い 彷徨う私にも
哪怕只有一点点 即使是处于彷徨中的我
彼方からLのhを届けて
也听见了从远方传来的风之歌