Bzoj5332: [Sdoi2018]旧试题

国际惯例的题面

首先我们进行一些相对显然的数学变化。

解释一下第二行的那个变形，如果一个数是ijk的因数，那么它一定能被分解成三部分分别是i,j,k的因数。
我们钦定一个质数只能在三部分的一个中出现。如果一个质数仅在ijk中的一个数中出现这样显然是对的，而在多个中出现的话，它贡献答案的次数为它出现的总次数+1次。
而考虑把ijk的乘积分解质因数，然后考虑每个质数的贡献，会发现每个质数贡献答案的次数恰好为它的次数+1次，所以这样是对的。
然后就是分析最后的这个公式了。
右边的三个小求和号里的东西显然可以大力nlog筛预处理一波，这样我们在知道lcm的时候能够O(1)求出这个求和号中的内容。
然后就是前面的东西了。
我们考虑枚举两个数，如果它们的lcm<=max(a,b,c)则相互连边，那么，对答案有贡献的显然就是图中的三元环了。
枚举三元环的话，我们显然有msqrt(m)的算法，其中m为边数。
这种做法就是把双向边都建成单向边，按照度数小的向大的点连或者反之(就像treap大根堆小根堆一样，只要一致了就行)，然后沿着边暴力枚举三个点即可，复杂度就是是msqrt(m)了(别问我证明，我不会QAQ)。
考虑lcm比max(a,b,c)小的数对很少，所以我们这题可以......卡过去。
既然是卡过去显然就要卡常数了......
首先μ为0的数我们显然不用算是吧。
另外直接枚举三元环的细节太多(这题存在自环)，于是我们先单独计算三个数相同的情况和三个数中有两个相同的情况。
存储边用vector存，在大量寻址的时候vector对缓存更加友好。
计算过程不用取模，最后输出再取模，因为答案不会超过long long(虽然听起来很没有道理)，中间即使溢出了也没有关系，只要别溢出超过一轮就行了。
另外最重要的，当你枚举按照边了三个点u,v,w后，是否要计算w和u的lcm来判断两者间是否有边呢？
看起来是需要的，然而并不用！
因为我们连边是存在单调性的，所以我们最终枚举出的三元环一定是u->v->w,u->w的形式。
于是我们在枚举三个点的时候可以先遍历一下u的出边标记下所有可行的w，然后枚举u->v->w之后直接查询lcm就好啦！
于是这样写就跑的飞起了，在BZOJ和洛谷上都是rank1啦。

代码:

还有两个OJ的rank:


生きてくって多分
只要活着
越えてかなきゃいけないよね
大概就不得不去跨越吧
その勇荬簸吻菲が
鼓起勇气
少しずつ婴出す
一点一点地转动梦的碎片
Kわりが始まる
即将迎来终结
何Iへ行くのなんて
连目标为何都不知道
わからないまま
就这样迷茫地
ただ^ぎてゆく
度过


未来はi解きの
不能让未来
ようにはいかないのかな
如谜题一般无法看清
o理に走って 空回りして
漫无目的的奔走着 不断地徒劳着
くじけそうだって
即使受挫
また笑ってたい
还想继续微笑着
rのを追いかけてちゃ
只是追逐着时钟的指针
何も守れない荬した
感觉什么也无法守护